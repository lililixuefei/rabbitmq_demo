# rabbitmq_demo
消息中间件 -- 学习RabbitMQ

#### 第一种模型（直连）

<img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png"/>

在上图的模型中，有以下概念：

- P：生产者，也就是发送消息的程序。
- C：消费者：消息的接受者，会一直等待消息的到来。
- queue：消息队列。图中红色部分。可以看作是生活中的邮箱，可以缓存消息；生产者向其中投递消息，消费者从中取出消息。



#### 第二种模型（work queue）

​	Work queues，也就称为（Task queues），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时可以使用 work 模型：**让多个消费绑定到一个队列，共同消费队列里面的消息。**队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。

​	                         <img src="https://www.rabbitmq.com/img/tutorials/python-two.png"  />

角色：

- P：生产者 -- 任务的发布者
- C1：消费者1 -- 领取任务并且完成任务，假设完成速度较慢
- C2：消费者2 -- 领取任务并完成任务，假设完成速度快

总结：默认情况下，RabbitMQ将按顺序将每个消息把每个消息发送给下一个使用者。平均而言，每个消费者都会受到相同数量的消息。这种分发消息的方式称为循环。

#### 消息自动确认机制

​	完成一项任务可能需要几秒钟，你可能会想，如果其中一个消费者开始了一项长期的任务，却只完成了一部分就死了，会发生什么呢？在我们当前的代码中，一旦RabbitMQ讲消息传递给消费者，它就会立即将其标记为删除。在这种情况下，如果你杀死了一个消费者，我们将丢失正在处理的消息。我们还将丢失发送给此特定工作进程但尚未处理的所有消息。但是我们不想死去任何任务。如果一个消费者死了，我们希望把任务交给另一个消费者